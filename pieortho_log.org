#+TITLE: PIEOrtho test log
#+AUTHOR: liutao
#+DATE: <2017-05-26 Fri>

* 测试记录

|-------------+------------------+----------+--------+-------+-------+-------|
| threads     |                  | original |      1 |     2 |     4 | 8(HT) |
|-------------+------------------+----------+--------+-------+-------+-------|
| small image | RPCCore()        |    30.10 |  34.08 | 18.46 | 10.14 |  7.25 |
| io: 2.49    | ExcutePIEOrtho() |    36.09 |  39.95 | 24.34 | 15.96 | 13.20 |
|-------------+------------------+----------+--------+-------+-------+-------|
| big image   | RPCCore()        |   122.15 | 136.57 | 74.24 | 47.27 | 44.10 |
| io: 7.23    | ExcutePIEOrtho() |   128.52 | 143.48 | 81.33 | 59.16 | 57.62 |
|-------------+------------------+----------+--------+-------+-------+-------|

* 优化过程

  - 工具： pthread
  - 寻找计算核心：上表中original一列是原始串行程序的测试结果，很明显，RPCCore()函数的运行时间占90%左右。
  - 优化计算核心：
    - 算法流程：
      for () {
        compute
        read
        compute
        write
      }
    - compute: 多线程
    - 关于I/O：
      - 按串行程序顺序读写（采用这种方法）
      - 锁+随机读写（尚未实现，因为Read和Write函数的具体实现不可见）
  - 测试
  - 检查结果正确性
      
* 进一步优化的想法

  1. 锁+随机读写，或改变读写的块的大小（需要知道Read和Write函数的实现）
  2. 使用我们开发的并行优化工具STAR
  3. 将来可以使用我们正在开发的大数据执行平台
